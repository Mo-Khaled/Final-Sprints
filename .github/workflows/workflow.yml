name: flask-employee-workflow

on:
  workflow_dispatch:
  push:
    branches:
      - main

env:
  MYSQL_HOST: ${{ vars.MYSQL_HOST }}
  MYSQL_USER: ${{ secrets.MYSQL_USERNAME }}
  MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
  MYSQL_DB: ${{ vars.MYSQL_DATABASE }}

jobs:
  unit_testing:
    name: unit_testing
    strategy:
      matrix:
        python-version: [3.8, 3.9, '3.10']
        os: [ubuntu-latest]
        exclude:
          - python-version: 3.8
            os: macos-latest
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v5

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-flask

      - name: Run Tests
        id: python-unit-testing-step
        run: pytest --tb=short || echo "Tests completed"

  code-coverage:
    name: code-coverage
    needs: unit_testing
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v5

      - name: Set up Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: 3.9

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Check Code Coverage
        continue-on-error: true
        run: pytest --cov=app --cov-report=html --cov-report=xml || echo "Coverage completed"


  docker:
    name: containerization
    needs: [unit_testing, code-coverage]
    permissions:
      packages: write
      contents: read
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v5

      - name: Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: GHCR Login
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            mo4222/flask-app:${{ github.sha }}
            ghcr.io/mo-khaled/flask-app:${{ github.sha }}

      - name: Test Docker Image
        run: |
          docker images
          docker run --name flask-app -d \
            -p 5000:5000 \
            -e MYSQL_HOST=${{ vars.MYSQL_HOST }} \
            -e MYSQL_USER=${{ secrets.MYSQL_USERNAME }} \
            -e MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
            -e MYSQL_DB=${{ vars.MYSQL_DATABASE }} \
            ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }}
          
          echo "Waiting for container to start..."
          sleep 10
          
          echo "Testing application health endpoint inside container"
          docker exec flask-app curl -f http://127.0.0.1:5000/live || exit 1


  terraform:
    name: terraform-deployment
    needs: [docker, code-coverage, unit_testing]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v5

      - name: AWS Login
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: 1.1.7

      - name: Terraform Init
        run: terraform init
        working-directory: ./Terraform/team1

      - name: Terraform Plan
        run: terraform plan
        working-directory: ./Terraform/team1

      - name: Terraform Apply or Destroy
        run: |
          if [ "${{ github.event.inputs.destroy }}" = "yes" ]; then
            terraform destroy -auto-approve
          else
            terraform apply -auto-approve
          fi
        working-directory: ./Terraform/team1

  deploy:
    needs: terraform
    name: deploy to EKS
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Config Files
        uses: actions/checkout@v5

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks --region us-east-1 update-kubeconfig --name sprints-cluster-0

      - name: Trigger App Deployment
        uses: statsig-io/kubectl-via-eksctl@main
        env:
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          region: us-east-1
          cluster: sprints-cluster-0

      - name: Deploy K8s Resources
        run: |
          kubectl apply -f mysql-secret.yml
          kubectl apply -f mysql-deployment.yml
          kubectl apply -f deployment.yml
          kubectl apply -f service.yml
        working-directory: ./k8s

      - name: Verify Deployment
        run: |
          kubectl get pods
          kubectl get svc

  deploy-monitoring:
        needs: deploy
        name: deploy monitoring to EKS
        runs-on: ubuntu-latest
        env: 
          AWS_REGION: us-east-1
          EKS_CLUSTER_NAME: sprints-cluster-0
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.grafana_admin_password }}

        steps:
            - name: checkout config files
              uses: actions/checkout@v5

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4.3.1
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: us-east-1

            - name: update kubeconfig
              run: | 
                    aws eks --region us-east-1 update-kubeconfig --name sprints-cluster-0

            - name: Trigger app deployment
              uses: statsig-io/kubectl-via-eksctl@main
              env:
                 aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                 aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                 region: us-east-1
                 cluster: sprints-cluster-0

            - name: Output monitoring namespace YAML
              run: kubectl create namespace monitoring --dry-run=client -o yaml
            - name: Create monitoring namespace
              run: kubectl create namespace monitoring || true

            - name: Add Helm repos
              run: |
                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                helm repo add grafana https://grafana.github.io/helm-charts
                helm repo update
            - name: Render values with env
              run: |
               envsubst < values.yml > /tmp/values.rendered.yml
               echo "Rendered values:"
               tail -n +1 /tmp/values.rendered.yml
              working-directory: ./k8s

            - name: Install/Upgrade kube-prometheus-stack
              run: |
                helm upgrade --install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
                  --namespace monitoring \
                  --values /tmp/values.rendered.yml \
                  --wait --timeout 15m
            - name: Apply ServiceMonitor for my app
              run: |
                kubectl apply -f servicemonitor.yml
              working-directory: ./k8s

            - name: Show external endpoints
              run: |
                echo "Waiting for LoadBalancer IPs..."
                kubectl -n monitoring wait --for=condition=available deploy/kube-prometheus-stack-grafana --timeout=10m
                kubectl -n monitoring get svc -o wide
                echo "Grafana URL:"
                kubectl -n monitoring get svc kube-prometheus-stack-grafana -o jsonpath='{.status.loadBalancer.ingress[0].hostname}{"\n"}{.status.loadBalancer.ingress[0].ip}{"\n"}'
                echo "Prometheus URL:"
                kubectl -n monitoring get svc kube-prometheus-stack-prometheus -o jsonpath='{.status.loadBalancer.ingress[0].hostname}{"\n"}{.status.loadBalancer.ingress[0].ip}{"\n"}'